<!DOCTYPE HTML><html lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)"><title>Deepfont on Keras | Unbinilium&#39;s üìù</title><link rel="preload" href="/css/style.css" as="style"><link rel="preload" href="/js/mathjax-loader.js" as="script"><link rel="preload" href="/js/mermaid-loader.js" as="script"><meta name="author" content="Unbinilium"><meta name="description" content="Unbinilium&#39;s draft papers, also the personal weblog"><meta property="og:title" content="Deepfont on Keras"><meta property="og:site_name" content="Unbinilium&#39;s üìù"><link rel="stylesheet" href="/css/style.css"><script src="/js/mathjax-loader.js" defer></script><script src="/js/mermaid-loader.js" defer></script><link rel="shortcut icon" href="/css/images/favicon.png"><meta name="generator" content="Hexo 5.4.0"></head><body><header id="header" class="inner"><div class="alignleft"><h1 translate="no"><a href="/">Unbinilium&#39;s üìù</a></h1><h2><a href="/">My draft papers, also the personal weblog</a></h2></div><nav id="main-nav" class="alignright"><ul></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div id="content" class="inner"><div id="main-col" class="alignleft"><div id="wrapper"><article id="post-deepfont-on-keras" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="post-content"><header><time class="dt-published" datetime="2020-11-01T00:00:00.000Z"><a href="">2020-11-01</a></time><h1 class="p-name title" itemprop="headline name">Deepfont on Keras</h1></header><div class="e-content entry" itemprop="articleBody"><p>Deepfont was first introduced by Adobe, which uses deep learning to identify font type. Inspired by their works, I made this reproduction using <a target="_blank" rel="noopener" href="https://keras.io">Keras</a>.</p><p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1507.03196v1.pdf">DeepFont: Identify Your Font from An Image</a></p><span id="more"></span><p>Their technical contributions are listed below:</p><ul><li><p><strong>AdobeVFR Dataset</strong> A large set of labeled real-world images as well as a large corpus of unlabeled real-world data are collected for both training and testing, which could be found at the link <a target="_blank" rel="noopener" href="https://github.com/tensorflow/datasets/issues/431">Adobe Visual Font Recognition (VFR)</a></p></li><li><p><strong>Domain Adapted CNN</strong> This real-to-synthetic domain gap caused poor generalization to new real data in previous VFR methods. They address this domain mismatch problem by leveraging synthetic data to obtain effective classification features, while introducing a domain adaptation technique based on Stacked Convolutional Auto Encoder (SCAE) with the help of unlabeled real-world data.</p></li><li><p><strong>Learning-based Model Compression</strong> They introduce a novel learning-based approach to obtain a losslessly compressible model, for a high compression ratio with- out sacrificing its performance. An exact low-rank constraint is enforced on the targeted weight matrix.</p></li></ul><h2 id="Datasets">Datasets</h2><p>To apply machine learning to VFR problem, both synthetic and realistic text images with ground truth font labels is required. The way to overcome the training data challenge is to synthesize the training set by rendering text fragments for all the necessary fonts.</p><h3 id="Synthetic-Text">Synthetic Text</h3><p>It‚Äôs easy to generate dataset based custom font image patches using <strong>TextRecognitionDataGenerator</strong>.</p><p><a target="_blank" rel="noopener" href="https://github.com/Belval/TextRecognitionDataGenerator"><strong>GitHub - TextRecognitionDataGenerator</strong></a></p><p>Words will be randomly chosen from a dictionary of a specific language. Then an image of those words will be generated by using font, background, and modifications (skewing, blurring, etc.) as specified.</p><p>TextRecognitionDataGenerator comes with an easy to use CLI and Python Module. It has a nice written tutorial.</p><p><a target="_blank" rel="noopener" href="https://textrecognitiondatagenerator.readthedocs.io/en/latest/tutorial.html#"><strong>TextRecognitionDataGenerator Tutorial</strong></a></p><h3 id="Realistic-Text">Realistic Text</h3><p><strong>AdobeVFR Dataset</strong> obtain 4,384 real-world test images with reliable labels, covering 617 classes (out of 2,383). Compared to the synthetic data, these images typically have much larger appearance variations caused by scaling, back- ground clutter, lighting, noise, perspective distortions, and compression artifacts.</p><h2 id="Preprocessing">Preprocessing</h2><p>Fonts are different with objects, which have huge spatial information when classify features. Aimed to reduce the mismatch, preprocessing is required and exampled by the paper.</p><p>Firstly, import needed modules.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PIL</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>Add <code>%matplotlib inline</code> as Magic Function if uses IPython to render images directly in browser. Otherwise, It would cause errors if you‚Äôre not using IPython.</p><p>Then code image load function.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pil_image</span>(<span class="params">img_path</span>):</span></span><br><span class="line">    pil_img = PIL.Image.<span class="built_in">open</span>(img_path).convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    pil_img = pil_img.resize((<span class="number">105</span>, <span class="number">105</span>))</span><br><span class="line">    <span class="keyword">return</span> pil_img</span><br></pre></td></tr></table></figure><h3 id="Legacy">Legacy</h3><p>It is usual to artificially augment training data using label-preserving transformations to reduce overfitting.</p><ul><li><strong>Noise</strong> a small Gaussian noise with 0 mean and standard deviation 3 is added to input.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noise_image</span>(<span class="params">img</span>):</span></span><br><span class="line">    img_array = np.asarray(img)</span><br><span class="line">    mean = <span class="number">0.0</span></span><br><span class="line">    std = <span class="number">3</span></span><br><span class="line">    noisy_img = img_array + np.random.normal(mean, std, img_array.shape)</span><br><span class="line">    noisy_img_clipped = np.clip(noisy_img, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    noise_img = PIL.Image.fromarray(np.uint8(noisy_img_clipped))</span><br><span class="line">    noise_img = noise_img.resize((<span class="number">105</span>, <span class="number">105</span>))</span><br><span class="line">    <span class="keyword">return</span> noise_img</span><br></pre></td></tr></table></figure><ul><li><strong>Blur</strong> a random Gaussian blur with standard deviation from 2.5 to 3.5 is added to input.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blur_image</span>(<span class="params">img</span>):</span></span><br><span class="line">    blur_img = img.<span class="built_in">filter</span>(PIL.ImageFilter.GaussianBlur(radius = <span class="number">3</span>))</span><br><span class="line">    blur_img = blur_img.resize((<span class="number">105</span>, <span class="number">105</span>))</span><br><span class="line">    <span class="keyword">return</span> blur_img</span><br></pre></td></tr></table></figure><ul><li><strong>Perspective Rotation</strong> a randomly-parameterized affine transformation is added to input.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">affine_rotation</span>(<span class="params">img</span>):</span></span><br><span class="line">    rows, columns = img.shape</span><br><span class="line"></span><br><span class="line">    point1 = np.float32([[<span class="number">10</span>, <span class="number">10</span>], [<span class="number">30</span>, <span class="number">10</span>], [<span class="number">10</span>, <span class="number">30</span>]])</span><br><span class="line">    point2 = np.float32([[<span class="number">20</span>, <span class="number">15</span>], [<span class="number">40</span>, <span class="number">10</span>], [<span class="number">20</span>, <span class="number">40</span>]])</span><br><span class="line"></span><br><span class="line">    anchor = cv2.getAffineTransform(point1, point2)</span><br><span class="line"></span><br><span class="line">    output = cv2.warpAffine(img, anchor, (columns, rows))</span><br><span class="line">    affine_img = PIL.Image.fromarray(np.uint8(output))</span><br><span class="line">    affine_img = affine_img.resize((<span class="number">105</span>, <span class="number">105</span>))</span><br><span class="line">    <span class="keyword">return</span> affine_img</span><br></pre></td></tr></table></figure><ul><li><strong>Shading</strong> the input background is filled with a gradient in illumination.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_fill</span>(<span class="params">img</span>):</span></span><br><span class="line">    output = cv2.Laplacian(img, cv2.CV_64F)</span><br><span class="line">    laplacian_img = PIL.Image.fromarray(np.uint8(output))</span><br><span class="line">    laplacian_img = laplacian_img.resize((<span class="number">105</span>, <span class="number">105</span>))</span><br><span class="line">    <span class="keyword">return</span> laplacian_img</span><br></pre></td></tr></table></figure><h3 id="Additional">Additional</h3><p>As a very particular type of images, text images have various real-world appearances caused by specific handlings. Based on the observations in the paper, they identify two additional font-specific augmentation steps to the training data.</p><ul><li><strong>Variable Character Spacing</strong> when rendering each synthetic image, set the character spacing (by pixel) to be a Gaussian random variable of mean 10 and standard deviation 40, bounded by [0, 50].</li><li><strong>Variable Aspect Ratio</strong> Before cropping each image into a input patch, the image, with heigh fixed, is squeezed in width by a random ratio, drawn from a uniform distribution between 5/6 and 7/6.</li></ul><p>It not convenient to do the additional steps for each characters, so loosely speaking, we could done this before legacy steps, at the beginning we generate our datasets using <em>TextRecognitionDataGenerator</em>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 run.py -c 10 -k 15 -rk -d 3 -do 2 -f 64 -ft [&#x27;Font1&#x27;, &#x27;Font2&#x27;, &#x27;Font3&#x27;] -t $(grep -c ^processor /proc/cpuinfo)</span><br></pre></td></tr></table></figure><p>This generate 10 examples with <em>Font1</em>, <em>Font2</em> and <em>Font3</em> which characters sized 64x64 with a skewing angle between -15 and 15 and a random distorsions both vertical and horizontal, multi-threads acceleration enabled.</p><p>Otherwise, it would be more difficult if we do as same as the paper. Firstly we generate single characters in same font with random aspect ratio follow the paper advice, the we flatten all these single characters with random spacing into many word, again we got a sentence in one image labeled by the font. Lastly by repeating these steps, we got images datasets with different fonts before applying legacy steps.</p><p>However, we‚Äôre supposed to do something which is similar to this at the end of datasets importing and actually I did it this way. To be clear why we could and should do this, I would clear that there‚Äôre something that I misunderstood and it totally different, just imaging the real situation when people tring to identify a font, the font would always be some part of some texts which has strong and clear characteristic, It‚Äôs the most important connection to our datasets, but the preprocessing solution I suggested before, just using the opponent side to undermine the most print font‚Äôs characteristic, through it may did some help on handwriting font recognition.</p><h2 id="Architecture">Architecture</h2><p>Domain adapted CNN employs a Convolutional Neural Network (CNN) architecture, which is further decomposed into two sub-networks:</p><ul><li><strong>A ‚Äúshared‚Äù low-level sub-network</strong> which is learned from the composite set of synthetic and real-world data.</li><li><strong>A high-level sub-network</strong> that learns a deep classifier from the low-level features.</li></ul><h4 id="Generate-Datasets">Generate Datasets</h4><p>Here we use the <em>Text Recognition Data Generator</em> CLI <code>trdg</code> to generate the random datasets.</p><ul><li><p><code>ttf_path</code> is a folder contains all the font file with correct font name and <code>.ttf</code> extension.</p></li><li><p><code>data_path</code> is a folder stores or contains generated datasets.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">ttf_path = <span class="string">&#x27;ttf_path&#x27;</span></span><br><span class="line">data_path = <span class="string">&#x27;datasets_path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(ttf_path):</span><br><span class="line">    <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.ttf&#x27;</span>):</span><br><span class="line">        path = os.path.join(ttf_path, file)</span><br><span class="line">        name, ext = os.path.splitext(os.path.basename(path))</span><br><span class="line">        out_path = data_path + <span class="string">&#x27;/&#x27;</span> + name</span><br><span class="line">        command = <span class="string">&#x27;trdg -l en -c 10 -rs -let -num -r --length 1 -b 1 -e .png -fi -f 105 -ft &#x27;</span> + path + <span class="string">&#x27; --output_dir &#x27;</span> + out_path</span><br><span class="line">        os.system(command)</span><br></pre></td></tr></table></figure><h3 id="Import-Datasets">Import Datasets</h3><p>Import pre-generated synthetic and realistic text images from <code>datasets_path</code> <em>(here especially the datasets we generated before)</em>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> imutils <span class="keyword">import</span> paths</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> seed, shuffle</span><br><span class="line"></span><br><span class="line">image_paths = <span class="built_in">sorted</span>(<span class="built_in">list</span>(paths.list_images(data_path)))</span><br><span class="line">random.seed(<span class="number">10</span>)</span><br><span class="line">random.shuffle(image_paths)</span><br><span class="line"></span><br><span class="line">font_names = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(data_path):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> f.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        font_names.append(f)</span><br><span class="line"></span><br><span class="line">font_names.sort()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Font Names -&gt; &#x27;</span>, font_names)</span><br></pre></td></tr></table></figure><h3 id="Tag-Labels">Tag Labels</h3><p>Convert font name string to integer and use the matched number as a font label when training models.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_label</span>(<span class="params">label</span>):</span></span><br><span class="line">    <span class="keyword">return</span> font_names.index(label)</span><br></pre></td></tr></table></figure><h3 id="Preprocessing-Datasets">Preprocessing Datasets</h3><p>Preprocessing functions are already finished, for each font patch images, effects should be applied randomly, so firstly we generate random combinations in 4 legacy preprocessing functions. Then apply the effects following the generated combinations list for all the font patch images.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> img_to_array</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line">labels = []</span><br><span class="line">auguments = [<span class="string">&quot;blur&quot;</span>, <span class="string">&quot;noise&quot;</span>, <span class="string">&quot;affine&quot;</span>, <span class="string">&quot;gradient&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> image_paths:</span><br><span class="line">    label = path.split(os.path.sep)[-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> label.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        label = conv_label(label)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    pil_img = pil_image(path)</span><br><span class="line">    org_img = img_to_array(pil_img)</span><br><span class="line"></span><br><span class="line">    data.append(org_img)</span><br><span class="line">    labels.append(label)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(auguments)):</span><br><span class="line">        <span class="keyword">for</span> augument <span class="keyword">in</span> <span class="built_in">list</span>(itertools.combinations(auguments, i + <span class="number">1</span>)):</span><br><span class="line"></span><br><span class="line">            temp_img = pil_img</span><br><span class="line">            combinations = <span class="built_in">list</span>(augument)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> method <span class="keyword">in</span> combinations:</span><br><span class="line">                <span class="keyword">if</span> method == <span class="string">&#x27;noise&#x27;</span>:</span><br><span class="line">                    temp_img = noise_image(temp_img)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> method == <span class="string">&#x27;blur&#x27;</span>:</span><br><span class="line">                    temp_img = blur_image(temp_img)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> method == <span class="string">&#x27;affine&#x27;</span>:</span><br><span class="line">                    open_cv_affine = np.array(pil_img)</span><br><span class="line">                    temp_img = affine_rotation(open_cv_affine)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> method == <span class="string">&#x27;gradient&#x27;</span>:</span><br><span class="line">                    open_cv_gradient = np.array(pil_img)</span><br><span class="line">                    temp_img = gradient_fill(open_cv_gradient)</span><br><span class="line"></span><br><span class="line">            temp_img = img_to_array(temp_img)</span><br><span class="line"></span><br><span class="line">            data.append(temp_img)</span><br><span class="line">            labels.append(label)</span><br></pre></td></tr></table></figure><p>According to the paper, 75% of the datasets is for training and the remaining 25% is for testing, so partition the data into training and testing is required.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">data = np.asarray(data, dtype = <span class="string">&quot;float&quot;</span>) / <span class="number">255.0</span></span><br><span class="line">labels = np.array(labels)</span><br><span class="line"></span><br><span class="line">(trainX, testX, trainY, testY) = train_test_split(data, labels, test_size = <span class="number">0.25</span>, random_state = <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>For further processing, both train and test labels of the datasets should be converted from integers to vectors.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line">trainY = to_categorical(trainY, num_classes = <span class="built_in">len</span>(font_names))</span><br><span class="line">testY = to_categorical(testY, num_classes = <span class="built_in">len</span>(font_names))</span><br></pre></td></tr></table></figure><p>Then process the datasets using additional preprocessing steps.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"></span><br><span class="line">augmented_images = ImageDataGenerator(</span><br><span class="line">    rotation_range = <span class="number">30</span>,</span><br><span class="line">    width_shift_range = <span class="number">0.1</span>,</span><br><span class="line">    height_shift_range = <span class="number">0.1</span>,</span><br><span class="line">    shear_range = <span class="number">0.2</span>,</span><br><span class="line">    zoom_range = <span class="number">0.2</span>,</span><br><span class="line">    horizontal_flip = <span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Create-Model">Create Model</h3><p>When the CNN model is trained fully on a synthetic dataset, it witnesses a significant performance drop when testing on real-world data, compared to when applied to another synthetic validation set. It alludes to discrepancies between the distributions of synthetic and real-world examples. They propose to decompose the <em>N CNN</em> layers into two sub-networks to be learned sequentially:</p><ul><li><p><strong>Unsupervised cross-domain sub-network C<sub>u</sub></strong>, which consists of the first <em>K</em> layers of <em>CNN</em>. It accounts for extracting low-level visual features shared by both syn- thetic and real-world data domains. C<sub>u</sub> will be trained in a unsupervised way, using unlabeled data from both domains. It constitutes the crucial step that further minimizes the low-level feature gap, beyond the previous data augmentation efforts.</p></li><li><p><strong>Supervised domain-specific sub-network C<sub>s</sub></strong>, which consists of the remaining <em>N ‚àí K</em> layers. It accounts for learning higher-level discriminative features for classi- fication, based on the shared features from C<sub>s</sub>. C<sub>s</sub> will be trained in a supervised way, using labeled data from the synthetic domain only.</p></li></ul><p>Firstly we modify the order of picture channels to avoid <code>OverflowError</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line">K.set_image_data_format(<span class="string">&#x27;channels_last&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Note the difference about the format which <code>keras</code> use in different versions.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">K.set_image_dim_ordering(<span class="string">&#x27;tf&#x27;</span>) --&gt; K.set_image_data_format(<span class="string">&#x27;channels_last&#x27;</span>)</span><br><span class="line">K.set_image_dim_ordering(<span class="string">&#x27;th&#x27;</span>) --&gt; K.set_image_data_format(<span class="string">&#x27;channels_first&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Secondly code create model function to define the architecture of the CNN layers.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers.normalization <span class="keyword">import</span> BatchNormalization</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten, Conv2D, MaxPooling2D , UpSampling2D ,Conv2DTranspose</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_model</span>():</span></span><br><span class="line">    model = Sequential()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Cu Layers</span></span><br><span class="line">    model.add(Conv2D(<span class="number">64</span>, kernel_size = (<span class="number">48</span>, <span class="number">48</span>), activation = <span class="string">&#x27;relu&#x27;</span>, input_shape = (<span class="number">105</span>, <span class="number">105</span>, <span class="number">1</span>)))</span><br><span class="line">    model.add(BatchNormalization())</span><br><span class="line">    model.add(MaxPooling2D(pool_size = (<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(<span class="number">128</span>, kernel_size = (<span class="number">24</span>, <span class="number">24</span>), activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(BatchNormalization())</span><br><span class="line">    model.add(MaxPooling2D(pool_size = (<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2DTranspose(<span class="number">128</span>, (<span class="number">24</span>, <span class="number">24</span>), strides = (<span class="number">2</span>, <span class="number">2</span>), activation = <span class="string">&#x27;relu&#x27;</span>, padding = <span class="string">&#x27;same&#x27;</span>, kernel_initializer = <span class="string">&#x27;uniform&#x27;</span>))</span><br><span class="line">    model.add(UpSampling2D(size = (<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2DTranspose(<span class="number">64</span>, (<span class="number">12</span>, <span class="number">12</span>), strides = (<span class="number">2</span>, <span class="number">2</span>), activation = <span class="string">&#x27;relu&#x27;</span>, padding = <span class="string">&#x27;same&#x27;</span>, kernel_initializer = <span class="string">&#x27;uniform&#x27;</span>))</span><br><span class="line">    model.add(UpSampling2D(size = (<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Cs Layers</span></span><br><span class="line">    model.add(Conv2D(<span class="number">256</span>, kernel_size=(<span class="number">12</span>, <span class="number">12</span>), activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(Conv2D(<span class="number">256</span>, kernel_size=(<span class="number">12</span>, <span class="number">12</span>), activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(Conv2D(<span class="number">256</span>, kernel_size=(<span class="number">12</span>, <span class="number">12</span>), activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Flatten())</span><br><span class="line">    model.add(Dense(<span class="number">4096</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">    model.add(Dense(<span class="number">4096</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">    model.add(Dense(<span class="number">2383</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(Dense(<span class="built_in">len</span>(font_names), activation = <span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p>Then create and compile model using Gradient descent (with momentum) optimizer with the CNN architecture network we created just now.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">epochs = <span class="number">50</span></span><br><span class="line">model= create_model()</span><br><span class="line">opt = optimizers.SGD(lr = <span class="number">0.01</span>, decay = <span class="number">1e-6</span>, momentum = <span class="number">0.9</span>, nesterov = <span class="literal">True</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(loss = <span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer = opt, metrics = [<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure><p>Periodically save my model to disk and get a view on internal states and statistics of a model during training.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> callbacks</span><br><span class="line"></span><br><span class="line">model_path = <span class="string">&quot;model_store_path&quot;</span></span><br><span class="line">my_callbacks = [</span><br><span class="line">    callbacks.EarlyStopping(monitor = <span class="string">&#x27;val_loss&#x27;</span>, min_delta = <span class="number">0</span>, patience = <span class="number">10</span>, verbose = <span class="number">0</span>, mode = <span class="string">&#x27;min&#x27;</span>)</span><br><span class="line">    callbacks.ModelCheckpoint(model_path, monitor = <span class="string">&#x27;val_loss&#x27;</span>, verbose = <span class="number">1</span>, save_best_only = <span class="literal">True</span>, mode = <span class="string">&#x27;min&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">model.fit(</span><br><span class="line">    trainX,</span><br><span class="line">    trainY,</span><br><span class="line">    shuffle = <span class="literal">True</span>,</span><br><span class="line">    batch_size = batch_size,</span><br><span class="line">    epochs = epochs,</span><br><span class="line">    verbose = <span class="number">1</span>,</span><br><span class="line">    validation_data = (testX, testY),</span><br><span class="line">    callbacks = my_callbacks</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Evaluate">Evaluate</h2><p>It‚Äôs necessary to evaluate a model after training to test whether it has meet our exceptions. If not, it means there would be some problem with our datasets or arguments used to compile.</p><h3 id="Load-Model">Load Model</h3><p>Load the model from <code>model_store_path</code> and print model evaluation information on the screen.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> load_model</span><br><span class="line"></span><br><span class="line">model_path = <span class="string">&quot;model_store_path&quot;</span></span><br><span class="line">model = load_model(model_path)</span><br><span class="line">score = model.evaluate(testX, testY, verbose = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test loss -&gt;&#x27;</span>, score[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test accuracy -&gt;&#x27;</span>, score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="Load-Image">Load Image</h3><p>Load the test image from <code>image_path</code> and preprocess with <code>blur_img</code> function, conver image to array.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PIL</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> img_to_array</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;image_path&quot;</span></span><br><span class="line"></span><br><span class="line">org_img = PIL.Image.<span class="built_in">open</span>(img_path).convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">pil_img = blur_image(org_img)</span><br><span class="line">pil_img = img_to_array(pil_img)</span><br></pre></td></tr></table></figure><h3 id="Inference">Inference</h3><p>Firstly code the lable restore function to convert font name from integer to string.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev_conv_label</span>(<span class="params">label</span>):</span></span><br><span class="line">    <span class="keyword">return</span> font_names[label]</span><br></pre></td></tr></table></figure><p>Then use loaded model to predict image array.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line">data.append(pil_img)</span><br><span class="line">data = np.asarray(data, dtype = <span class="string">&quot;float&quot;</span>) / <span class="number">255.0</span></span><br><span class="line">y = np.argmax(model.predict(data), axis = -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>Lastly, show the prediction results.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">label = rev_conv_label(<span class="built_in">int</span>(y[<span class="number">0</span>]))</span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>)</span><br><span class="line">ax.imshow(org_img, interpolation = <span class="string">&#x27;nearest&#x27;</span>, cmap = cm.gray)</span><br><span class="line">ax.text(<span class="number">5</span>, <span class="number">5</span>, label, bbox = &#123; <span class="string">&#x27;facecolor&#x27;</span>: <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;pad&#x27;</span>: <span class="number">8</span> &#125;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div><footer><div class="tags" translate="no"><a href="../../../../tags/Machine-Learning/">Machine Learning</a></div><div class="clearfix"></div></footer></div></article></div></div><aside id="sidebar" class="alignright"><div class="widget tag"><h3 class="title">Tags</h3><ul class="entry" translate="no"><li><a href="../../../../tags/About/">About</a> <small>1</small></li><li><a href="../../../../tags/C/">C++</a> <small>1</small></li><li><a href="../../../../tags/IDE/">IDE</a> <small>2</small></li><li><a href="../../../../tags/Linux/">Linux</a> <small>1</small></li><li><a href="../../../../tags/Machine-Learning/">Machine Learning</a> <small>1</small></li><li><a href="../../../../tags/OpenCV/">OpenCV</a> <small>4</small></li><li><a href="../../../../tags/Parallel-Programming/">Parallel Programming</a> <small>1</small></li><li><a href="../../../../tags/Windows/">Windows</a> <small>1</small></li><li><a href="../../../../tags/macOS/">macOS</a> <small>1</small></li></ul></div></aside><div class="clearfix"></div></div><footer id="footer" class="inner" translate="no"><div class="alignleft">&copy; 2021 Unbinilium</div><div class="clearfix"></div><script src="/js/sidebar-wrapper.js" async></script><script src="/js/code-notranslate.js" async></script></footer></body></html>